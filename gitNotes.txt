Basic Introduction to Devops
===============================

Devops : Devops is not the tool/ technology as most of the people think. Infact its a culture/process that software companies follow to develop , release and maintenance  of software application/project/product with high quality and in very fast way by using automation tools.

In any software product, there are two group of engineer works:
1. Development group
2. Operation/Non-Development/Administrator(BA)

Development Group: People who are involved in below areas are considered as development group:

1. Planning 
2. Coding
3. Build
4. Testing

Eg
Business analyst/BA
System analyst
design architect
developers
build engineer
test engineer/qa

Operation group: The people who are involved in  below are considered as operation group:

1. Release
2. Deployment
3. Operations
4. Monitoring

Eg.
Configurtion engineer
System admin
Monitoring team

To understand Devops culture, we needs to have understanding of SDLC(software development life cycle)

1. Waterfall model
2. Prototype model
3. INcrementatl/Iterative model
4. Spiral model
5. RAD model
6. Big-bang model
7. Fish model
8. V model
9. Agile model
10. Deveps model

Importal models to discuss:
1. Waterfall model(Linear Sequential model) - Everything works here step by step. Next step can only start when previous one is finished.
Requirement gathering/collection(BA)
`Requirement analysis(SA)
``Design
```Development
````Testing
`````Release
``````Maintenance

This methodology is not frequently used because of the frequent requirement change and less development time.

2. Agile Model:
This is the most frequently used model. This model is divided into multiple sub models
1. Rational unify process(RUP)
2. Adaptive software development(ASD)
3. Feature driven development(FDD)
4. Crystal clear
5. Dynamic software development method(DSDM)
6. Extreme Programming(xp)
7. SCRUM model, etc

Among all these models, SCRUM is most frequently used and popular model.

Agile => Speed
SCRUM =>It is an iterative model in which software product is developed in increment and each incremetn is called as sprint.

SCRUM is derived from Rugby game.
In every sprint 7-9 members will work
each sprint will be delivered from 1 week to 3 weeks.

3. Devops model
Devops and Agile both are different methodologies. However there are some similarities as well :
1. Both are software development methodologies.
2. Both models concentration on rapid software development

Differences:
1. The difference will come once development of the project completed.
Agile model talks about only development but not operation. However, Devops model talks about complete product life cycle like development and operation.


2. In agile model, sepate people are responsilble for development, testing, deployment etc. However  in deveps, the devops engineer is responsible for everything like development to operation and operation to development.

3. Agile model wont force us to use automation tools. However devops model is completely based on automation.

4. Agile is always giving highest priority for speed. But deveops giving priority for quality and speed.

5. In agile, client is responsible for providing feedback. But id devops. immediate feedback is available from the monitoring feedback.

Version Control System tool:
======================================
Verson control system is also known as software configuration management(SCM) or source code management(SCM).

Need of version control system?
-------------------------------
1. Maintaining multiple versions manually is very tedious task.
2. Each and every change should be tracked.
	Who did the change
	when he did the change
	which changes he did etc
3. Overwriting of the code should not happen.

4. Developers have to share their code to peer developers, so that multiple developers will work in collaborative way.
5. Parallel development must be required.

How version control system works:
----------------------------------

Version conrol system always talks about files which contains source code.

Version control is required by developer, tester, manager, architect who ever have multiple version of the file.

========================================
Basic Terminonlogy of Versoin  Control System

Working directory/Workspace => The files where developers create the file and writes the code. WD doesn't have the version.

Repository => In repository, all files are stored in the form of version. Any change in the file is stored in the form of new version.


Commit => When developer make any change in the working directory and save to Repository, this operation is known as commit


Checkout => When developer want any version from repository to current working directory is called as checkout.

========================================
Type of Version Control Systems:
=======================================

1. Centralized Version Control System
2. De-Centralized/Distributed version control system

1. Centralized Version Control System
---------------------------------------
Centralized-> These types of version control system contain only one central repository. Every developer is required to connect with that to continue his work. 

Developers will commit and checkout on central repository server as total project code is stored there.

It is easy to setup but has some limitation:

1. If anything happens to Central Repository server, its difficult to recover the code base as everything is stored in single place.

2. All checkout and commmit operations has to be performed by connecting to Central Repo Server which means all the developers have to be connected to Central Repo. If network outage is there then developer cannot commit or checkout.

3. If no of files or the developers increases, it becomes quite difficult to again manage the code.

2. Distributed Version Control System
------------------------------------------

Repository is distributed.

In this system, every workspace has local repository.

1. All commit and checkout operations will be perfomed locally and hence performance is more.

2. If network outage, still version control is available.

3. There is no question of single point of failure.

commit and checkout:
----------------------
**These operations will be perfomred locally between working directory and repository.
To perform these operations, network is not required.

push & pull operations:
-------------------------
push: The process of sending files from our repository to other's repository.
pull: The process of getting files from other's repository to local repository.

** push and pull will be perfomed between 2 repositories.
These are remote operations.
Compulsory internet should be there.

Distributed VCS with Remote Repository
--------------------------------------

Remote VS Centralized Repository.
1. Commit and checkout operations are performing on local repository not on remote repository.

2. Every developer has their own local repository along with remote repository at server.

Main job of remote repository is to share the complete work to peer developer

GIT
===================

GIT is Distributed version control system tool.

Linux => It is not an operating system. Its is just a Kernal.Operating system name is GNU. It is famous as GNU/Linux
Linus Torvals(Finnish Software Engineer) On his name itself Linux was named and earlier those days every software used to end with (x).
GIT is developed by Linus Torvalds.

Features of GIT:
------------------
1. Distributed Model:
a) No single point of failure.Every developer has local repository.
b) All commit and checkout are performed locally and hence performance and speed is more.
c) Developer workspace needs not to be connected to network always.

2) Staging area:
-----------------
In GIT commit is 2-step process. 
First we have to add files to staging area from working directory and then we can commmit from that staging area to Repository.

Advantage of staging area is we can cross check or double check out changes before commit.

To store 12GB of files, GIT only requires 420 MB. It use Hash alogrith internally.GIT takes snapshot when files are staged from staging area.

3) Branching and Merging:
--------------------------
We can create and work on multiple branches simultaneously and all these branches are isolated from each other. It enables multiple workflows.

5. Freeware and open source:
GIT is free and available on most of the platform.

GIT Architecture:
--------------------
Git has 2 repos:
1. Local Repo
2. Remote Repo

Usually total project code is available in remote repo.

Current work of developer will be stored in local repo.

New files will be created in working directory.
Once work completed, we have to add these files to staging area. For this we have to use command:
git add => Sending files from working directory to staging area

git commit => Staged changes will be moved to local repo.

git push => Move local repo changes to Remote Repo

git clone => Creates  a new local repo from the remote repo

git pull => Gets updated fles from remote repo to local repo

Life Cycle of file in GIT:
---------------------------
Every file in the git, one of the following 4 stages,
1. Untracked
2. Staged
3. Modified
4. In Repository/Commited

Untracked:
---------------
Whenever a new file is created in working directory, GIT is not aware and also do not start tracking it. It starts tracking once the file is added to the staging area.

git status : To known status of all the file in all the area.

Staged:
----------
The files which are added to staging area are said to be in staged state.

git add a.txt => Add only a.txt file to staging area
git add . => Add all the files to staging area
git add a.txt b.txt c.txt => Add multiple files a.txt, b.txt, c.txt to staging area
git add *.txt => Adds all the file with .txt extension to the staging area.

Commited:
---------
The files which is committed is said to be in repository state or committed state. In order to commit the files first user info has to be config

git config --global user.email "abc@gmail.com"
git config --global user.name "abc"

Once user is configured in the git, next time onwards use the command 
For single line commit message
git commit -m "Your message for the commit"
OR
For multiple line commit message
git commit (Enter)
Type commit Message from editor and save

Modified:
-----------
If the file added to staging area or committed, it is tracked by git. Whenever the same file in working directory is update, the status becomes modified

OR

Any file which is already tracked by git,but it is modified in working directory is said to be in modified state.

git log => Command to view lods by version.

How to install git on windows:
-------------------------------

1. Open https://git-scm.com/download/win

2. Click on "Click here to download" Or choose based on your computer bit.

3. Install the executable file.

Steps for using git
Open GitBash

pwd => Shows current working directory

mkdir "Directory Name" => Create a new working directory

cd D:"Directory Name" => Change working directory

ls => shows all the files within the current working directory

ls -a => shows all the files including hidden files from the current working directory

Git by default do not knows which field needs to be track. For that we need to instruct git by following command

git init => Create a empty local repo. It adds a .git(name of local Repo) hidden folder in the working directory and enables version controlling.


cat > A.txt
This is first line.
=> Create a text file with the date in current Working directory.

mv "fileName" "directoryName" => moves file to the specified directory.

At the time of git init => Nothing is tracked. Files has to move to stage inorder to start tracking

git ls-files => Show information about files in the index and the working tree

If git is already initialized than again initiazaling doesn't make any change in staging or commit area. Only some internal memory refresh happens.

git commit -a -m "Commit Message" = >Directly Commit with staging(Only applicable for modified file not for new file)

Example to describe basic GIT commands:
-------------------------------------------------

Create a new project in folder:
mkdir project2

Enter into project2 directory
cd project2

By default version control is not applicable for this workspace(project2).

Now we have to request GIT to start version controlling by following command:

1. git init
---------
Once we create workspace, and if we want version control to be enabled,
we require a local repository ==> .git
If any file starts with . then by default its a hidden directory.

ls -a => Display all files including hidden file

2. git status:
----------------------
It shows the current status of all files in each area, like 
untracked files,
modified files,
stages files, etc.

cat > file1.txt 
First line in file1.txt
=> Creates a new file current working directory

cat > file2.txt 
First line in file2.txt
=> Creates a new file current working directory

if check status again using git status
it will show the file1.txt and file2.txt are untracked

It display verbose output which mean very details output. However if want concise output than use -s with git status
Ex git status -s
?? indicates untracked
A indicates files added to staging area

3.git add
----------------
To add files from working directory to staging area.Once we added files to staging area, then git track these files and ready for commit.

git add file1.txt file2.txt

staging area is also known as index area or cache area. It is logical/virtual area but not physical area

i) To add all files to staging area
	git add . 
	git add *
	git add -a
ii) To add particular files 
	git add file1.txt file2.txt
iii) We can use even regular expression patterns also
	git add *.java
	git add *.txt

git ls-files => Displays which files tracked by git.

4. git commit:
---------------------
If we want to commit staged changes, then we have to use git commit. All the files which are in staging area gets committed to local repo. 

git commit -m "commit message"

In order to commit we need to provide the message

For every commit , commit id will be generated. This Commit id is hash which is hexadecimal number of 40 characters.

For every commit git records below are tracked:
author name and mail id
timestamp
commit message

git commit -a -m "Commiting and staging file at same time" => It only works when file is already in staging area

5. git log:
----------------
It shows history of all commits
commit it
author name and mail id
timestamp
commit message



Master is the most recent commit. Master is pointed by another reference HEAD.(Symbolic reference =>  Reference to another reference)

git config:
---------------
This command can be used for git configuration like username, email id, etc.

git config --list
	To listout all the git configutations

git config user.name
	Display user name configured for git

git config user.name "New Name"
	It will override the old username with new name

git --global config user.name "New Name"

without global config vs with global config
------------------------------------------
For all repo which is managed by current git==>global

Without global means: configuration applicable for current repo.

It is recommended not to use global we might have to work on multiple project where remote repo are different and username also need to be different.

git log:
--------
If we want to see history of all commits in local repository we can use git log command
It's most commonly used command

cat > z.txt
Hello first line inside z.txt

git ls-files //New files are not tracked by default

git add z.txt //It starts tracking now

git commit -m " A new file z.txt added" //File commited to local repo

git status //Nothing is there as everything is committed

git log // Its going to display all the commit history that has been done as of now in the local repo.

git log provides detailed log information
	commit id, author, date, commit message

Optional commands available with git log command:
-------------------------------------------
git log --help //Provides the help menu for git log command

How to see log information of a particular file:
---------------------------------------------

git log z.txt

Option-1: --oneline option to get brief information
git log 
	detailed information
	commit Id(40 chars)
	author name and email
	timestamp
	commit message

git log --oneline
	display one line per commit
	commit Id(7 chars)+ commit message

**** This option is very helpful if we have lot of commits and to identify commit based on message.

Option-2: -n option to limit the number of commits to display:
---------------------------------------------------
git log -n 2 => It will show the last two commits
git log -3 => display last 3 commits
git log --max-count=4 =>  display last 4 commits

Option-3: --grep option to search based on given pattern in the commit message.

git log --grep="added" => It will display all the commit with message where added string is available

Option-4: Show commits more recent than a specific date or time.
------------------------------------------------

--since="2022-04-01" => After 25 do we have any commit

--after="2022-04-01"

--after="10 days ago"

--after="3 hours ago"
--after="3 hours 5 minutes ago"
--after="10 minutes ago"

Option-5: Show commits older than a specific time
-------------------------------------------------
git log --until="2022-02-02"
git log --before="2022-02-02"

Option-6: Show  commits based on author:
---------------------------------------------
git log --author="Name of author"

Option-7: --decorate option to display extra information
--------------------------------------------
branch, name, HEAD, tags information etc

git log --decorate


git diff
-----------

Our files are stored in 4 areas:
1. Working directory
2. Staging area
3. Local Repository
4. Remote Repository

Once file is created in working directory then we add file to staging area after that file from staging area is commited to local repository and  finally from local repository to remote repository.
Now users can make any change in any file in any area and there can be difference between these files. Using git diff command we can find out the difference between the files.


This is very comman requirement. In the content of a file:
	Working directory Vs Staging area
	Working directory vs local repo
	Staging area vs last commit
	staging area vs specified commit
	etc....

Project Demo:
--------------

mkdir Project4 //Creates working directory with name Project4
cd Project4 //Navigated inside Project4
git init //Initializes git for source tracking
cat > file1.txt // create file1.txt with below 2 line
First line in file1.txt
Second line in file1.txt

cat > file2.txt // create file2.txt with below 2 line
First line in file2.txt
Second line in file2.txt


git add . //Add all the files in directory to staging area

git commit -m "Each file contains two lines" //Commit all the files from staging area to local repo

Now add 2 more lines in file1.txt
cat >> file1.txt
Third line in file1.txt
Fourth line file1.txt

Now add 2 more lines in file1.txt
cat >> file2.txt
Third line in file2.txt
Fourth line file2.txt

git commit -am "2 files and each file contains 4 lines" //Directly commits the file working directory to staging area

Add more lines in file1.txt //Appends one more line
cat >> file1.txt
Fifth line in file1.txt

git add .

cat >> file1.txt
Sixth line in file1.txt

Now every area has different number of lines.

case-1: To see difference in file content between working directory and staging area:
----------------------------------------------------------
git diff file1.txt
	To compare working directory and staging area for file1.txt

1) diff --git a/file1.txt b/file1.txt
a/file1.txt => source copy which means staging area
b/file2.txt => Destination copy which means working directory

2) index 8445405..246caab 100644
8445405 => hash of source file content(staging area)
246caab	=> hash of destination file content(working directory)
100644	=> GIT File mode where 100 represents type of file ASCII text and 644 represents file permission

3) --- a/file1.txt
	Source copy missing some lines(staging area)
4) +++ b/file1.txt
	Means new lines added in destination copy (working directory)

5) @@ -3,3 +3,4 @@

-3,3
-means source version
From 3rd line total 3 lines

+3,4 
 + means destination version
from 3rd line onwards total 4 lines

These numbers are not fixed this vary from use case

 Third line in file1.txt
 Fourth line in file1.txt
 Fifth line in file1.txt
+Sixth line in file1.txt

If any line prefixed with space that means its unchanged and if any line prefixed with + mmeans it is added in destination copy.

We can conclude one new line added in working copy when compared with staged copy.

Git is always going to compare from right to left like staging to working directory.

2) Working directory vs last commit:
-----------------------------------------
last commit can be referenced by HEAD.

git diff HEAD file1.txt 

3) Staging vs last Commit
-----------------------------
We have to use  -staged option or --cached option

git diff --staged HEAD file1.txt
git diff --staged file1.txt

4) Working directory Vs Specific Commit
-------------------------------------------
git diff commitId file1.txt

5) Staging vs specific commit
---------------------------------
git diff --staged commitId file1.txt

6) Between two specified commits
---------------------------------
git diff commitId-1 commitId-2 file.txt

git diff commitId-2 commitId-2 file.txt

7) Between last commit vs last but one commit
----------------------------------------------
commit-7
commit-6
commit-4
commit-3
commit-2
commit-1

git diff HEAD HEAD~1 file1.txt

To see difference in content between two branches:
----------------------------------
git diff master test

To see difference in local repository and remote repository:
-------------------------------------------------------------

git diff master origin/master

Summary:
------------
1) Working directory vs staged copy
	git diff file1.txt

2) Working directory vs last commit
	git diff HEAD file1.txt

3) Staging area vs last commit
	git diff --staged HEAD file1.txt

4) Working directory vs specific commit:
	git diff commitId file1.txt

5) Staging area vs specified commit:
	git diff --stage commitId file1.txt

6) Between two commits
	git diff source_commit_id destination_commit_Id file1.txt

7) last commit vs last but one commit:
	git diff HEAD HEAD^1 file1.txt
	git diff HEAD HEAD~^1 file1.txt

8) To compare all files
	git diff source_commit_id destination_commit_id

9) Two brances in local repo
	git diff source_branch_name destination_branch_name

10) Local repo vs remote repo:
	git diff localbranchname remotebranchname

GUI/Visual tool for checking differences:
------------------------------------------
Helix Visual Merge Tool(p4merge),
Meld,
etc....

p4Merge => Its acts as Merga and diff tool as well.
perforce 4 Merge => p4merge

How to download and install p4merge tool:
-------------------------------------------

https://www.Perforce.com/downloads/visual-merge-tool
Download based on Operating system compatibility and you can skip registration.

Install the executable file p4vinst64.exe
Select only Merge and Diff tool and keep selecting next next.

In order to Use p4merge for git bash, we need to set the path 

This PC>Properties>Advance setting> Environment Variable > Path > New > Add the Path of Perforce.

Perforce is generally installed in C:\Program Files\Perforce

How to configure p4merge with git:
-------------------------------------
difftool configuration:
-----------------------
git config --global diff.tool p4merge
git config --global difftool.p4merge.path "C:\Program Files\Perforce\p4merge.exe"

path where exe file is availabe = C:\Program Files\Perforce\p4merge.exe

git config --global difftool.prompt false

mergetool configuration
------------------------
git config --global merge.tool p4merge
git config --global mergetool.p4merge.path C:\Program Files\Perforce\p4merge.exe"
git config --global mergetool.prompt false

git config --global --list //Displays config including p4merge settings

Now run git difftool file1.txt //This will open a gui and will show the difference in more user friendly way.

Only difference is instead of diff, we need to use difftool.

Working directory Vs Staging Area:
----------------------------------
git difftool file1.txt

Working directory vs last commit:
-----------------------------------
git difftool HEAD file1.txt

Between two commits:
---------------------
git difftool commitId1 commitId2 file1.txt

To remove files from different areas:
---------------------------------------
git rm command

Example:
---------

mkdir "project5"
cd project5
git init
vi file1.txt Add line "First line in file1.txt"
vi file2.txt Add line "First line in file2.txt"
vi file3.txt Add line "First line in file3.txt"

All these 3 files are now available in working directory and now we need to track it

git add .
git status

git commit -m "3 new files added"

Now these 3 files are available in working directory, staging area, local repo.

Below are possible scenarios:
----------------------------
To remove files from both staging area and working directory
To remove files from only staging are but not from working directory
To remove files only from working directory
To remove files from local repo //Using git Ignore

Case -1 To remove files from both staging area and working directory
------------------------------------------------------------
git rm file1.txt

ls //(Without git)check file present in working directory
	// Displays file1.txt file2.txt file3.txt
git ls-files //(With git)
	//Displays file in staging area
	//file1.txt, file2.txt, file3.txt

git rm file3.txt // Remove file from Working directory and Staging area

now check ls and ls-files file1.txt has been removed

git commit -m 'file3.txt removed from both wd & staging'

git rm // Without any argument it will get an error

git rm . -r// With -r it will delete all the files

git commit -m 'all files from both wd and staging area removed'



Case-2: To remove files from only from staging area but not from working directory:
------------------------------------------------------------
vi file4.txt //Add First line in file4.txt
vi file5.txt //Add First line in file5.txt

git add .
git commit -m "file4.txt and file5.txt added"

git rm --cached file4.txt //Removes file from staging area

Case-3: To remove file only from working directory but not from staging area:
---------------------------------------------------
git command is not there, we can use normal linux command

rm file4.txt //Deletes the files from working directory

git ls-files //Files is still present in staging area

git checkout command:
---------------------
We can use checkout command to discard unstaged changes in the tracked files of working directory.
Unstaged changes => The chnges which are not added to staging area.
tracked files=> The files which are tracked by git.

Example:
-----------
mkdir project6
cd project6
git init
vm file1.txt //Add "First line in file1.txt
vm file2.txt //Add "First line in file2.txt

git add .
git commit -m 'Both files has been added'

vi file1.txt //Add 'Second line in file1.txt'

git add file1.txt
vi file1.txt //add 'third line in file1.txt'

git diff file1.txt

git checkout --file1.txt //Bring back staged changes to working directory
git checkout //It listout the files for which checkout is applicable.

After checkout, working directory copy and staged copy have same content.

git checkout . => Bring all changes from staged area to working directory.

If a new file is created and its not in staging area than this cannot be discarded. It only works with tracked file.

git references:
------------------
For most of the commands (like git log, git diff etc) we have to use commit ids as arguments. But remembering these commit id is very difficult. 

40 length commit id || 7 characters.

Git provides some sample names for these commit ids. We can use these names directly instead of commit ids. These are just pointers to commit ids.
These sample names are nothing but references or refs.

git references are pointers to commit ids.

The most recent commit id => master or HEAD 

.git/refs directory stores all the references.

heads, tags and remotes.

Example:
------------

mkdir 'project7'
cd project7
git init
vi file1.txt // add 'First line in file1.txt'
git add file1.txt
git commit -m 'first commit'

//One commit done

git log now displays the commit info along with id.

What is master?
------------------
1. Master is name of the branch. 
2. It is a reference(pointer) to last commit. Hence wherever last commit id required, we can use simply master.

git show commitId => Display info related to the commit like lines added or removed,etc
git show master => If we need info related to the last commit and we don't want to supply commitId, we can use master keyword which refereces the last commit id.

master => Last commit
master~1 => Second last commit
master~2 => Third last commit and so on

What is HEAD:
---------------
Head is reference to master. It is a reference to another reference which is generally called as symbolic reference.

By default HEAD is always pointing to the master.

.git/refs/heads/master

HEAD information is available in .git directory.

git show commitId //Display info related to particular commit Id
git show master	//Display info related to last commit id
git show HEAD //Display info related to master i.e. last commit id if branch is not detached
git show HEAD~1 //Display info related to second last master i.e. second last commit id if branch is not detached

Detached HEAD:
-------------
Sometimes HEAD is not pointing to branch name, such type of HEAD is called detached HEAD.

git reset command:
--------------------
Just like reset to default settings.

There are two utilities of git reset command:
----------------------------------------------
1. To remove changes from staging area
2. To undo commits at repo level

To remove changes from staging area:
------------------------------------
It will bring changes from staging area back to working directory.
It is opposite to git add command.

Example:
---------

mkdir 'project7'
cd project7
git init
vi file1.txt //add 'First line in file1
git add file1.txt
git commit -m 'First commit'
git status //Working tree is clean
vi file1.txt //Add 'Second line in file1'
git status //Working tree is not clean as modified file is there
git add file1.txt
git status //On branch master, changes to be commited will be displayed
git reset file1.txt //Changes from staging area will be reverted

git checkout vs git reset:
---------------------------
git checkout can be used to discard unstaged changes in working directory
git reset can be used to discard staged changes from staging area

git rm -- rm cached vs git reset:
---------------------------------
git rm --cached => It will delete the file from staging area
git reset file1.txt => The file won't be deleted from staging area but reset to previous state.(one step back)

Q. We modified the content of file1.txt and added to staging area. But we want to ignore those changes in both staging area and in working directory.
A. git reset file1.txt
   git checkout --file1.txt
To undo commits at repository level
-------------------------------------
We can also use reset to undo commit at repo level.

syntax:
--------
git reset <mode> commitid 
	Moves the HEAD  to the specified  commit and all remaining recent commits will be deleted from repository.

It is not possible to delete specific commit.
Mode will decide whether these changes are going to remove from staging area or not , from working directory or not.
Deletion of file is permanent.

The allowed values for the mode are:
	--mixed
	--soft
	--hard
	--keep
	--merge
--mixed reset mode:
--------------------
It is the default mode.
git reset --mixed commitId
git reset commitId

To discard/remove commits from repo and from staging area also.
It won't touch working directory.
We can revert because changes are available in working directory.

Example:
---------

mkdir project8
cd project8
git init
vi file1.txt //add 'first line in file1
vi file2.txt // add 'first line in file2

vi file3.txt // add 'first line in file3

git add file1.txt
git commit -m 'File 1 added'

git add file2.txt
git commit -m 'file2 added'

git add file3.txt
git commit -m 'file3 added'

git log --oneline

To remove last commit:
----------------------
git reset --mixed commitId
git reset commitId
git reset --mixed HEAD~1
git reset HEAD~1
(all are same)

1. To add file to repo again
 	git add file3.txt
	git commit -m 'File3 added again'
2. git checkout --file3.txt

To remove last 2 commits:
-----------------------

git reset --mixed HEAD~2
git reset --mixed commitID

GIT Aliasing:
---------------
Alias => Nickname or other alternative name.
We usually use mutlitple command very commanly like:
git log --oneline
git status

We can define our own nickname for most commanly used lengthy command.
Ex:
git log --oneline --oneline --decocate => git deco

Q1. Create alias name 'one' to the following command
	git log --oneline
	
A1. 

Step 1: Check whether alias name already used or not:
-------------------------------------------------
git one

Step 2: Creating alias name:
----------------------------
Original command: git log --oneline
alias:one

By using git config command we can define aliases:
Syntax:
git config --global alias.aliasName "Original command without git keyword"

eg:
git config --globla alias.one "log --oneline"

Now you can use:
git one

Q2. Create alias name 's' for the following git command
	git status

A2. 
	git s //Git s is not a command that means it can be used
	git config --global alias.s "status"
	git s //Run the command
	
Where these aliases are stored?
----------------------------------

.gitconfig file 
In user's home directory
C:\Users\lenovo

How to ignore unwanted files and directory:
--------------------------------------------
In repo, we are saving our files for future purpose. But there are some files which you might not want to place.

We have to create a special file in working diretory:
	.gitignore

Example:
---------
touch customer.java Account.java a.txt b.txt //Create 4 files
touch .x .y //Create two hidden files

mkdir logs
touch logs/server.log log/access/log //Create two folder with files

git status //All files are untracked as of now

Now we want a.txt to be ignored

vi .gitignore //Create in working directory
#Ignore a.txt file //Comment
a.txt //File name to be ignore

git status
a.txt will not be displayed and hence it will be ignored by git.

Ignore all .txt files:
----------------------
vi .gitignore

# Ignore all .txt files
*.txt //Provide  regular expression pattern.

git status //It will not display all .txt files

Ignore all hidden files:
--------------------------

vi .gitignore

#Ignore all hidden files
.* //Any file name starting with . ie hidden file

git status //Now all hidden files are ignored

Ignore all files in particular directory
----------------------------------------
vi .gitignore
# Ignore all files present in logs directory
logs/


How git treats directories:
----------------------------
Git always worries about files but not directories.
Git never give any special importance for directories.

Whenever we add empty directory, then git status do not considers it. However if we add files to directory, its going to show that directory is untracked.

Branching:
--------------
1. What is branching?
2. What is the need of creating a new branch?
3. Various commands related to branches>
4. Demo Example
5. Multiple scenario where branching is required?
6. Advantages of brances?
7. Merge Operation.
8. How to resolve merge conflicts?


1. Important concept 
2. Mandatory concept and unavailable concept

We created multiple files
We did several commits

are said to be in master branch.

master branch is default branch/main branch in git.

Generally main source code we will place in master branch.

What is the need of creating a branch?
---------------------------------------
Master branch is the responsible for developing web application.
Child branch 1 is responsible for Android compatibilty work
Child branch 2 is responsible for ios compatibility work

Multiple flows => Parallel development is possible, code base is very clean

Conclusion:
------------
1. Once we create a branch, all files and commits will be inherited from parent branch to child branch.
In child branches we can create new files and we can perform any changes in existing file and we can commit those changes based on our requirement.

2. All branches are isolated to each other. The changes performed in one branch are not visible.

3. Once we completed our work in child branch, we can merge that new branch with branch or we can push that branch directlyy to the remote repo.

There is no restriction on number of branches. Any number of branches can be created.

Various commands related to branching:
--------------------------------------

1. To view available branches:
-----------------------------
	git branch

	* master (* means default and is provided by git)
	* indicates the current active branch

2. To create a new branch:
--------------------------
git branch branch_name
git branch androidbr

git branch
androidbr
* master

3. How to switch from one branch to another branch:
---------------------------------------------------
git checkout => To discard unstaged changes in working directory

git checkout androidbr

shortcut way to create branch and switch to branch:
---------------------------------------------------

git checkout -b isobr
	//It will create iosbr and then switch to that branch

Branch Demo
--------------

mkdir project 8
cd project8

git init
touch a.txt b.txt c.txt

git add a.txt; git commit -m 'a.txt added'

git add b.txt; git commit -m 'b.txt added'

git add c.txt; git commit -m 'c.txt added'

git log --oneline

git branch //only master branch is available

Suddenly client came and asked to work on new feature:

So we need to create a new branch

git branch 'androidbr'
git checkout androidbr

git branch

ls // all file are present in new branch androidbr
git status // all commit is also available in android br

1. All files and commits inherited.

touch x.txt y.txt z.txt //New files in androidbr
git add x.txt; git commit -m 'x.txt added'
git add y.txt; git commit -m 'y.txt added'
git add z.txt; git commit -m 'z.txt added'

2.	Master =3 files and 3 commits
	AndroidBr = 6 files and 5 commits

git checkout master //switch to master branch
git branch //display master branch
ls //3 files
git log --onelne //3 commits only

touch d.txt //New file in master branch

git add.txt' git commit -m 'd.txt added'

ls //4 files in master branch
git log --oneline //4 commits in master

This new file and commit are added in master branch and is not accessible in android branch. Because android br was created before D.txt creation. Hence it proves, all branches are isolated to each other.

Q. Is git creating a new directory?
A. Git wont create any new directory

Q. Is git copy all the files from parent to child?
A. It is logical duplication of files not physical.

Head pointer will be changed to current active branch.

Multiple use cases where branching is required?
------------------------------------------------
1. We required to develop a new feature.
2. Hot fixes in production.
3. To support multiple version of same code base
4. To test new ideas or new technologies

Advantages of branching:
------------------------
1. We can enable parallel development
2. We can work on multiple flows in isolated way
3. We can organize source code in clean way
4. Implementing new features will become very easy
5. Bug fixing will become very easy.
6. Testing new ideas or new technologies will become very easy.








